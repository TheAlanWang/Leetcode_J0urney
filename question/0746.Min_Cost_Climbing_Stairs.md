## Question
The goal is to compute the minimum cost to reach the **top** of the floor. (`idx = len(cost)`)

 Example 1:
> Input: cost = `[10,15,20]`  
> Output: 15
> Explanation: You will start at index 1. Pay 15 and climb two steps to reach the top. The total cost is 15.

## Method 1 - DP

### Approach - 1D DP
- Dynamic Programming

Q: Why `dp` need size `n+1`?
- The **top** of the floor is just beyond the last step, at index `n`.
- `dp[n]` represent the minimum cost to reach the top.
- `dp[i]` = minimum cost to reach step `i`. 

#### Sample
```
3               _______
2          _____|20
1    _____|15
0___| 10

cost: [10 15 20]
dp: [0, 0, 10, 15]
idx: 0 1 2 3
```
#### Complexity
- Time complexity: O(n)
- Space complexity: O(n)
### Code
```python
def minCostClimbingStairs(self, cost: List[int]) -> int:
	n = len(cost)
	dp = [0] * (n + 1)

	for i in range(2, n + 1):
		dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
	return dp[-1]
```

## Method 2 - DP SC: O(1)

### Complexity
- Time complexity: O(n)
- Space complexity: O(1)
### Code
```python
def minCostClimbingStairs(self, cost: List[int]) -> int:
	n = len(cost)
	prev2, prev1 = 0, 0 # dp[0], dp[1]

	for i in range(2, n + 1):
		curr = min(prev1 + cost[i-1], prev2 + cost[i-2])
		prev2, prev1 = prev1, curr

	return prev1
```
