## Question

## Method - DP:
0/1 Knapsack: Each item can be taken at most once
### Approach
- Outer loop `nums`:
	- Inner loop: backwards loop `target` to `num`
		- avoid using the same number multiple times
#### Complexity
- Time Complexity: O(n * target)
- Space Complexity: O(target)
### Code
```python
class Solution:
    def canPartition(self, nums):
        total = sum(nums)
        if total % 2 == 1:
            return False
        
        target = total // 2

        #if max(nums) > target:
        #    return False
        
        dp = [False] * (target + 1)
        dp[0] = True

        for num in nums:
            for idx in range(target, num - 1, -1):
                dp[idx] = dp[idx] or dp[idx - num]
        return dp[target]
```

## Mistake
- `range(target, num - 1, -1)`