link: [3607. Power Grid Maintenance](https://leetcode.com/problems/power-grid-maintenance/)
## Question
 If station `x` is offline, the check is resolved by the operational station with the smallest `id` in the same **power grid** as `x`.
### Intuition
- Use DSU to find the component

## Method 1 - DSU + Heap
### Approach
1. Define DSU
	- initial: `list(range(n))`
	- find
	- union
2. union the component by using `connections`
3. create DSU `root`  hashmap `{root1: [heap], root2: [heap]}`
4. create `online`, default is true
5. loop `queries`
	1. when `online[heap[0]]]` False
		1. heappop
#### Complexity
- Time Complexity: $O((m+c+q)logc)$
	- Build DSU -  O(m α(c))  -> edge
	- heapify: $O(c*log*c)$
	- queries: q
- Space Complexity: O(c + Q)
	- O(c) is DSU parent
	- O(c + Q)
### Code
```python
class DSU:
    def __init__(self, n):
        self.parent = list(range(n)) # [0, 1, 2, 3 ... n]

    def find(self, x):
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    
    def union(self, x, y):
        rootX = self.find(x)
        rootY = self.find(y)
        if rootX != rootY:
            self.parent[rootX] = rootY

class Solution:
    def processQueries(self, c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:
        dsu = DSU(c)

        for u, v in connections:
            dsu.union(u - 1, v - 1)
        
        component_heap = defaultdict(list)
        for i in range(c):
            root = dsu.find(i) # 0-based
            heapq.heappush(component_heap[root], i) # 0-based {0:heap, 1:heap}
        
        online = [True] * c
        res = []
        for flag, x in queries:
            x -= 1 # 0_based
            if flag == 1:
                if online[x]:
                    res.append(x + 1)
                else:
                    root = dsu.find(x)
                    heap = component_heap[root]
                    while heap and not online[heap[0]]:
                        heapq.heappop(heap)
                    
                    if heap:
                        res.append(heap[0] + 1)
                    else:
                        res.append(-1)

            else:
                online[x] = False
            
        return res
```
## Method 2 - BFS
### Approach
#### Complexity
- Time Complexity: $O(Q(c+E))$
- Space Complexity: $O(c+E)$
### Code
```python
class Solution:
    def processQueries(self, c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:
        dic = [[] for _ in range(c)]
        for u, v in connections:
            u -= 1
            v -= 1
            dic[u].append(v)
            dic[v].append(u)
        for i in range(c):
            dic[i].sort()

        def find_next(idx):             # zero_base to find
            queue = deque()
            visited = set()
            queue.append(idx)
            visited.add(idx)
            min_online = float('inf')
            while queue:
                node = queue.popleft()

                if stations[node]:
                    min_online = min(min_online, node)

                for nei in dic[node]:
                    if nei not in visited:
                        queue.append(nei)
                        visited.add(nei)

            return min_online + 1 if min_online != float('inf') else - 1

        stations = [True] * c
        res = []
        for flag, idx in queries:
            idx -= 1                        # zero_base
            if flag == 1:
                if stations[idx]:           
                    res.append(idx + 1)     # return 1_base
                else:                       
                    out = find_next(idx)    # zero_base to find
                    res.append(out)
            elif flag == 2:
                stations[idx] = False
        
        return res
```