## Link
[Subsets II - LeetCode](https://leetcode.com/problems/subsets-ii/description/) - medium
## Question
>Given an integer arrayÂ `nums`Â that may contain duplicates, returnÂ _all possible_Â _subsets_Â _(the power set)_.
>The solution setÂ **must not**Â contain duplicate subsets. Return the solution inÂ **any order**.
>
>**Example 1:**
>>**Input:** nums = `[1,2,2]`<br>
>>**Output:** `[[],[1],[1,2],[1,2,2],[2],[2,2]]`

## Goal:
Weâ€™re asked to return all possible subsets of a list, including duplicates in the input. But the result should contain **only unique subsets**, no duplicates.
## Logic
1. Sort the input first â€” so duplicate elements are adjacent
2. Inside the for-loop, skip duplicates using condition
3. Recursion step:
	- Add the current subset to the result.
	- Loop through the input from `start` to end.
	- For each `nums[i]`, 
	    - Include it (`path.append`)
	    - Recurse deeper (`start = i + 1`)
	    - Backtrack (`path.pop()`) to try the next number
## Code:
```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        self.backtrack(0, [], nums, res)
        return res

    def backtrack(self, idx, curr_subset, nums, res):
        res.append(curr_subset[:])
        for i in range(idx, len(nums)):
            if i > idx and nums[i] == nums[i - 1]:
                continue
            curr_subset.append(nums[i])
            self.backtrack(i + 1, curr_subset, nums, res)
            curr_subset.pop()
```

## Complexity analysis
- Time Complexity: O($n * 2^n$)
- Space Complexity: O($n * 2^n$)
## Pre-knowledge
- backtracking
## Sample: 
### ğŸ“˜ Backtracking Trace for `nums = [1, 2, 2]`
---
#### ğŸ”¢ Step â‘ : `backtrack(start=0, path=[])`
- â• `res = [[]]` âœ…
##### ğŸ” Loop:
- `i = 0` â†’ choose `1`
    - `path = [1]`
    - â­ Recurse â†’ Step â‘¡
---
#### ğŸ”¢ Step â‘¡: `backtrack(start=1, path=[1])`
- â• `res = [[], [1]]`
#### ğŸ” Loop:
- `i = 1` â†’ choose `2`
    - `path = [1, 2]`
    - â­ Recurse â†’ Step â‘¢
---
#### ğŸ”¢ Step â‘¢: `backtrack(start=2, path=[1, 2])`
- â• `res = [[], [1], [1, 2]]`
##### ğŸ” Loop:
- `i = 2` â†’ choose `2`
    - `path = [1, 2, 2]`
    - â­ Recurse â†’ Step â‘£

---
#### ğŸ”¢ Step â‘£: `backtrack(start=3, path=[1, 2, 2])` âœ… **Base Case Hit**
- â• `res = [[], [1], [1, 2], [1, 2, 2]]`
â†©ï¸ Pop â†’ `path = [1, 2]`  
â¬…ï¸ Return to Step â‘¢

---

â¬…ï¸ Backtrack to Step â‘¢  
â†©ï¸ Pop â†’ `path = [1]`  
â¬…ï¸ Return to Step â‘¡

##### ğŸ” Continue Loop in Step â‘¡:
- `i = 2` â†’ duplicate of `nums[1] = 2` 
    - ğŸ” `i > start and nums[i] == nums[i - 1]` â†’ **Skip**

â†©ï¸ Pop â†’ `path = []`  
â¬…ï¸ Return to Step â‘ 

---
#### ğŸ”¢ Step â‘¤: Back at `start=0`, Loop Continues
- `i = 1` â†’ choose `2`
    - `path = [2]`
    - â­ Recurse â†’ Step â‘¥

---
#### ğŸ”¢ Step â‘¥: `backtrack(start=2, path=[2])`
- â• `res = [[], [1], [1, 2], [1, 2, 2], [2]]`
#### ğŸ” Loop:
- `i = 2` â†’ choose `2`
    - `path = [2, 2]`
    - â­ Recurse â†’ Step â‘¦

---
#### ğŸ”¢ Step â‘¦: `backtrack(start=3, path=[2, 2])` âœ… **Base Case Hit**
- â• `res = [[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]`
â†©ï¸ Pop â†’ `path = [2]`  
â¬…ï¸ Return to Step â‘¥

â†©ï¸ Pop â†’ `path = []`  
â¬…ï¸ Return to Step â‘ 

---
#### ğŸ” Loop in Step â‘  continues:
- `i = 2` â†’ duplicate of `nums[1] = 2`
    - ğŸ” Skip (duplicate at same level)

---
## âœ… Final `res`:

```python
[[], [1], [1, 2], [1, 2, 2], [2], [2, 2]]
```
