## Question
[743. Network Delay Time](https://leetcode.com/problems/network-delay-time/)
## Method 1 - Dijkstra

### Approach (heap)
- State:
	- `dist = [float('inf')] * (n + 1)` → a distance array that stores the shortest known
	- `heap = [(0, k)]` → a min-heap (priority queue) storing pairs `(cur_dist, node)` where:
		- `cur_dist` = current known shortest distance to this node
- Approach
	1. Build the `graph`
	2. Initialize `dist`
	3. loop
		1. pop smallest `cur_dist`
		2. skip outdate path
		3. relaxation step (Try to use one edge to make the shortest path to the target node shorter.)
			1. `new_dist = cur_dist + w`
### Complexity 
- Time Complexity: O($E + VlogV$)
	- build the heap: `O(VlogV)`
	- traverse: `O(E)`
- Space Complexity: O($V+E$)
### Code
```python
from typing import List
from collections import defaultdict
import heapq

class Solution:
    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:
        
        graph = defaultdict(list)

        for u, v, w in times:
            graph[u].append((v, w)) #next_node, weight
        
        dist = [float('inf')] * (n + 1)
        dist[k] = 0
        heap = [(0, k)] # dist, node

        while heap:
            cur_dist, node = heapq.heappop(heap)
            
            if cur_dist > dist[node]:
                continue
            
            for nei, w in graph[node]:
                new_dist = cur_dist + w
                if new_dist < dist[nei]:
                    dist[nei] = new_dist
                    heapq.heappush(heap, (new_dist, nei))
        
        res = max(dist[1:])
        
        return res if res != float('inf') else -1
```
