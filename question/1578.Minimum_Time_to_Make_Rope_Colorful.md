## Method 1 - Greedy
#### Complexity
- Time Complexity: O(n)
- Space Complexity: O(1)
### Code
```python
class Solution:
    def minCost(self, colors: str, neededTime: List[int]) -> int:
        res = 0
        prev = ''          # previous color
        max_in_run = 0     # max time seen in the current same-color run

        for c, t in zip(colors, neededTime):
            if c == prev:
                # same-color run: keep the larger time, delete the smaller one(s)
                res += min(max_in_run, t)
                max_in_run = max(max_in_run, t)
            else:
                # new color starts a new run
                prev = c
                max_in_run = t
        return res
```
## Method 2 - intuition
### Approach - intuition
#### Complexity
- Time Complexity: O(n)
- Space Complexity: O(n)
### Code
```python
class Solution:
    def minCost(self, colors: str, neededTime: List[int]) -> int:
        dup = []
        idx, n = 0, len(colors)
        while idx < n - 1:
            region = []
            if colors[idx] == colors[idx + 1]:
                dup_color = colors[idx]
                region.append(idx)
                while idx < n - 1 and dup_color == colors[idx + 1]:
                    region.append(idx + 1)
                    idx += 1
            
            dup.append(region[:])
            idx += 1
        
        res = 0

        for area in dup:
            if not area:
                continue
            total = 0
            max_time = 0
            for idx in area:
                total += neededTime[idx]
                if max_time < neededTime[idx]:
                    max_time = neededTime[idx]
            
            res += total - max_time
        
        return res
```