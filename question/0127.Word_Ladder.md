## Link
[Word Ladder - LeetCode](https://leetcode.com/problems/word-ladder/description/) - hard
## Question
> **Example 1:**
>> **Input:** beginWord = "hit", endWord = "cog", wordList = `["hot","dot","dog","lot","log","cog"]`
>> **Output:** 5
>> **Explanation:** One shortest transformation sequence is `"hit" -> "hot" -> "dot" -> "dog" -> cog"`, which is 5 words long.
### Goal:
- Find the **shortest number of transformations** from `beginWord` to `endWord`
- Differs by a single letter

## Questions:
- Q: 
## Method 1 - BFS
### Approach
- BFS
1. Hash_set for Fast lookup
2. Initial BFS queue
	- `visited` Set
		- avoid cycle check
		- only add when `new_word` hasn't been visited yet
		- avoids process the same word multiple times
	- alphabet for replace the word
3. BFS Loop
	- level by level
4. If not path found
	- return 0
#### Complexity
- Time Complexity: $O(n*L^2)$
	- BFS take O(n) loop `next_word` take `O(L*26*L)`
	- $O(n) * O(L^2)$
- Space Complexity: $O(n*L)$
### Code
```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        wordList_set = set(wordList)
        if endWord not in wordList_set:
            return 0
        if beginWord == endWord:
            return 1
        
        queue = deque([beginWord])
        visited = set([beginWord])
        count = 1

        while queue:
            for _ in range(len(queue)):
                word = queue.popleft()
                
                for i in range(len(word)): # O(L)
                    for c in 'abcdefghijklmnopqrstuvwxyz':
                        new_word = word[:i] + c + word[i + 1:] # O(L)
                        if new_word == endWord:
                            return count + 1
            
                        if (new_word in wordList_set 
                            and new_word not in visited):
                            queue.append(new_word)
                            visited.add(new_word)
            count += 1
        return 0
```

## Method 2 - Bidirectional BFS
### Code
```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        wordSet = set(wordList)

        beg_set = {beginWord}
        end_set = {endWord}
        visited = set()
        step = 1

        if endWord not in wordSet:
            return 0

        while beg_set and end_set:
            if len(beg_set) > len(end_set):
                beg_set, end_set = end_set, beg_set
            next_level = set()
            for word in beg_set:
                for i in range(len(word)):
                    for char in 'abcdefghijklmnopqrstuvwxyz':
                        new_word = word[:i] + char + word[i + 1:]
                        if new_word in end_set:
                            return step + 1
                        if new_word in wordList and new_word not in visited:
                            visited.add(new_word)
                            next_level.add(new_word)
            beg_set = next_level
            step += 1
        
        return 0
```