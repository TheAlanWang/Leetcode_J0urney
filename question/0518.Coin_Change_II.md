## Question
- Find how many ways we can make up a target amount using the given coins.

Example 1:
> **Input:** amount = 5, coins = [1,2,5]
> **Output:** 4
> **Explanation:** there are four ways to make up the amount:
> 5=5
> 5=2+2+1
> 5=2+1+1+1
> 5=1+1+1+1+1
## Method 1: DP
### Approach:  
- Dynamic Programming (Complete knapsack)
### Transitions:  
- `dp[i]` = number of ways to make up amount
	- `dp[i] += dp[i - coin]`

Q: Why use `+=`?
- we **accumulate** the number of combinations contributed by each coin.
### Approach:
* Time Complexity: O(n * amount)
* Space Complexity: O(amount)

```python
from typing import List

class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0] * (amount + 1) # record count
        dp[0] = 1
        
        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] += dp[i - coin]
        
        return dp[-1]
```

## Method 2: 
Approach: DFS
- Time Limit Excees
```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        coins = sorted(coins)
        
        def dfs(idx, total):
            if idx == len(coins) or total > amount:
                return 0
            
            if total == amount:
                return 1
            
            take = dfs(idx, total + coins[idx])
            skip = dfs(idx + 1, total)

            return take + skip

        return dfs(0, 0)
```