# 0518.Coin_Change_II

Clarification:  
    Find how many ways we can make up a target amount using the given coins.

Approach:  
- Dynamic Programming(Complete knapsack)

Transitions:  
- dp[x] += dp[x - coin]   # add the number of ways to form (x - coin)

## Method 1:
* TC: O(n * amount) | SC: O(amount)

```python
from typing import List

class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0] * (amount + 1) # record count
        dp[0] = 1
        
        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] += dp[i-coin]
        
        return dp[-1]
```

### Method 2: 
Approach: DFS
- Time Limit Excees
```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        coins = sorted(coins)
        
        def dfs(idx, total):
            if idx == len(coins) or total > amount:
                return 0
            
            if total == amount:
                return 1
            
            take = dfs(idx, total + coins[idx])
            skip = dfs(idx + 1, total)

            return take + skip

        return dfs(0, 0)
```