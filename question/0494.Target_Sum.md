## Method 1 - DFS (with memo)
### Approach
Top-down + Memoization
### Complexity
- Time Complexity: O(n * sum(nums))
- Space Complexity: O(n * sum(nums))
### Code
```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:

        memo = {}

        def dfs(start, total):
            if (start, total) in memo:
                return memo[(start, total)]
            
            if start == len(nums):
                return 1 if total == target else 0
            
            memo[start, total] = (
                dfs(start + 1, total - nums[start]) + 
                dfs(start + 1, total + nums[start])
                )            
            return memo[(start, total)]

        
        return dfs(0, 0)
```

store `res` into memo, then return res
```python
memo[start, total] = (
	dfs(start + 1, total - nums[start]) + 
	dfs(start + 1, total + nums[start])
	)            
return memo[(start, total)]

res = dfs(start + 1, total - nums[start]) + dfs(start + 1, total + nums[start])
memo[(start, total)] = res
return res
```