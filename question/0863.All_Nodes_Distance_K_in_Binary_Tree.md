
## Question
The question is to find all nodes that are at distance `k` distance from a given `target` node.

## Method 1 - DFS + BFS
### Approach
1. DFS, implement parent_dictionary record {node, parent}
2. BFS, from target to find the k distance element (node.left, node.right, par)
### Complexity
- Time Complexity: O(n)
- Space Complexity: O(n)
	- par_dic, visited, BFS queue
### Code
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:

        par_dic = {}    # {node, par} 

        def dfs(node, par):
            if not node:
                return None
            
            par_dic[node] = par
            dfs(node.left, node)
            dfs(node.right, node)

        dfs(root, None)

        queue = deque()
        visited = set()
        queue.append((target, 0))
        visited.add(target)
        res = []
        while queue:
            node, dist = queue.popleft()
            if dist == k:
                res.append(node.val)
                continue
            for nei in (node.left, node.right, par_dic[node]):
                if nei and nei not in visited:
                    queue.append((nei, dist + 1))
                    visited.add(nei)
            
        return res
```