[Rotting Oranges - LeetCode](https://leetcode.com/problems/rotting-oranges/description/) - medium

## Question
> You are given an `m x n` `grid` where each cell can have one of three values:
>
> - `0` representing an empty cell,
> - `1` representing a fresh orange, or
> - `2` representing a rotten orange.
>
> Every minute, any fresh orange that is **4-directionally adjacent** to a rotten orange becomes rotten.
> Return the minimum number of minutes that must elapse until no cell has a fresh orange\*. If this is impossible, return `-1`.

> **Example 1:**
>
> > Input: grid = `[[2,1,1],[1,1,0],[0,1,1]]`
> > Output: 4

## Method 1 - BFS

### Approach

1. Track state:
   - `fresh`: count the number of fresh oranges
   - `minutes`: to record how many steps it takes to rot all fresh oranges
2. Use BFS
   - level by level,
   - use `queue` to record next orange affect
     BFS logic:
   1. loop `queue`
   2. for each rotten orange, infect 4 neighbor
   3. if fresh orange is infected, mark it as rotten
   4. after processing full level, increment minutes
3. Exit:
   - if fresh is 0, return minutes
   - if `queue` empty but `fresh > 0`, return `-1`

### Complexity analysis

- Time Complexity: O(`m*n`)
- Space Complexity: O(`m*n`)

### Code
```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        if not grid or not grid[0]:
            return 0

        rows, cols = len(grid), len(grid[0])
        queue = deque()
        fresh = 0

        # init: push all rotten, count fresh
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == 2:
                    queue.append((r, c))
                elif grid[r][c] == 1:
                    fresh += 1

        if fresh == 0:
            return 0

        minutes = 0
        dirs = ((1, 0), (-1, 0), (0, 1), (0, -1))

        while queue and fresh > 0:
            size = len(queue)

            for _ in range(size):
                r, c = queue.popleft()
                for dr, dc in dirs:
                    nr, nc = r + dr, c + dc
                    if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:
                        grid[nr][nc] = 2      # mark visited by rotting it
                        queue.append((nr, nc))
                        fresh -= 1

            minutes += 1

        return minutes if fresh == 0 else -1
```

#### Error:
- Missing fresh-orange count causes incorrect `0` return.
