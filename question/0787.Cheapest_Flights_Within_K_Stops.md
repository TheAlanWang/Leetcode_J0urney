## Question:
- At most k stops: means search k+1 times -> `max_edge = k + 1`

## Method 1
### Approach - Bellman–Ford
`dist[v] = min cost to reach v using up to e edges after e-th iteration`
- only need to iterate `k+1` times
- run exactly (k+1) rounds (allowing up to k+1 edges)
### Complexity
- Time Complexity: O(`E*K`)
- Space Complexity: O(`N*K`)
### Code
```python
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        dist = [float('inf')] * n
        dist[src] = 0

        for _ in range(k + 1):            # allow up to k+1 edges
            next_dist = dist[:]           # copy to avoid chaining within the same round
            for u, v, w in flights:       # relax every edge once per round
                if dist[u] != float('inf') and dist[u] + w < next_dist[v]:
                    next_dist[v] = dist[u] + w
            dist = next_dist

        return -1 if dist[dst] == float('inf') else dist[dst]
```

## Method 2
### Approach - Dijkstra's Algorithm (heap + graph)

#### DP table
- Use DP Table (2D-Matrix): keeps track of “the cheapest way to reach each city with a certain number of flights."
```
dist = [
  [0,   inf, inf],  # city 0: with 0 flights, cost is 0
  [inf, inf, inf],  # city 1: 
  [inf, inf, inf],  # city 2: 
  [inf, inf, inf],  # city 3: 
]
```
`dist = [[float('inf')] * (max_edges + 1) for _ in range(n)]`
- `dist[2][1]` means: the cheapest cost from city 0 → city 2 using exactly 1 flight.
- `dist[2][2]` means: the cheapest cost from city 0 → city 2 using exactly 2 flights.
### Complexity
- Time Complexity: O(`E*K`)
- Space Complexity: O(`N*K`)
### Code
```python
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        graph = defaultdict(list)
        for u, v, price in flights:
            graph[u].append((v, price))

        max_edges = k + 1 # at most k stops
        dist = [[float('inf')] * (max_edges + 1) for _ in range(n)]
        dist[src][0] = 0

        # 最小堆： (当前总费用, 当前城市, 已用边数)
        pq = [(0, src, 0)]

        while pq:
            curr_cost, city, edges = heapq.heappop(pq)

            # 堆顶弹出即为当前花费最小的状态；若已到终点，直接返回
            if city == dst:
                return curr_cost

            # 如果这个状态不是我们记录的最优（过时状态），跳过
            if curr_cost > dist[city][edges]:
                continue

            # 边数已经达到上限时，不再扩展
            if edges == max_edges:
                continue

            # 扩展相邻城市
            for nxt, price in graph[city]:
                next_edges = edges + 1
                next_cost = curr_cost + price
                if next_cost < dist[nxt][next_edges]:
                    dist[nxt][next_edges] = next_cost
                    heapq.heappush(pq, (next_cost, nxt, next_edges))

        return -1
```