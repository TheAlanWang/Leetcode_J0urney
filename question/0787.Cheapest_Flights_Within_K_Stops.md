## Question:

- At most k stops: means search k+1 times -> `max_edge = k + 1`
- return the cheapest price from `src` to `dst` with *at most* `k` stops.

## Method 1

### Approach - Bellman–Ford

```
dp[e][v] = min( dp[e-1][v], dp[e-1][u] + w(u,v) )
```

`dist[v] = min cost to reach v using up to e edges after e-th iteration`

- only need to iterate `k+1` times
- run exactly (k+1) rounds (allowing up to k+1 edges)

### Complexity
- Time Complexity: O(`E*K`)
	- Outer loop O(k+1) times.
	- Inside loop O(E) time, `dist[:]` take O(n) times
- Space Complexity: O(`N`)
	- `dist` and `next_dist` O(n)

### Code

```python
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        dist = [float('inf')] * n
        dist[src] = 0

        for _ in range(k + 1):
            next_dist = dist[:]

            for start, end, cost in flights:
                if dist[start] != float('inf') and dist[start] + cost < next_dist[end]:
                    next_dist[end] = dist[start] + cost

            dist = next_dist

        return dist[dst] if dist[dst] != float('inf') else -1
```

## Method 2

### Approach - Dijkstra's Algorithm (heap + graph)

#### DP table

- Use DP Table (2D-Matrix): keeps track of “the cheapest way to reach each city with a certain number of flights."

```
dist = [
  [0,   inf, inf],  # city 0: with 0 flights, cost is 0
  [inf, inf, inf],  # city 1:
  [inf, inf, inf],  # city 2:
  [inf, inf, inf],  # city 3:
]
```

`dist = [[float('inf')] * (max_edges + 1) for _ in range(n)]`

- `dist[2][1]` means: the cheapest cost from city 0 → city 2 using exactly 1 flight.
- `dist[2][2]` means: the cheapest cost from city 0 → city 2 using exactly 2 flights.

### Complexity

- Time Complexity: O(`E*K`)
- Space Complexity: O(`N*K`)

### Code

```python
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:
        graph = defaultdict(list)
        for u, v, price in flights:
            graph[u].append((v, price))

        max_edges = k + 1 # at most k stops
        dist = [[float('inf')] * (max_edges + 1) for _ in range(n)]
        dist[src][0] = 0

        # 最小堆： (当前总费用, 当前城市, 已用边数)
        pq = [(0, src, 0)]

        while pq:
            curr_cost, city, edges = heapq.heappop(pq)

            # 堆顶弹出即为当前花费最小的状态；若已到终点，直接返回
            if city == dst:
                return curr_cost

            # 如果这个状态不是我们记录的最优（过时状态），跳过
            if curr_cost > dist[city][edges]:
                continue

            # 边数已经达到上限时，不再扩展
            if edges == max_edges:
                continue

            # 扩展相邻城市
            for nxt, price in graph[city]:
                next_edges = edges + 1
                next_cost = curr_cost + price
                if next_cost < dist[nxt][next_edges]:
                    dist[nxt][next_edges] = next_cost
                    heapq.heappush(pq, (next_cost, nxt, next_edges))

        return -1
```
