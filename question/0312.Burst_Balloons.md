## Question
Given n balloons, each with a number.
When u brust ballon `i`, u get `nums[i-1] * nums[i] * nums[i+1]` coins.
Return the maximum coins.
## Analysis
- Why use DP?
	- need the **maximum coins** after bursting all balloons. `left` and `right` change after each burst.
	- Means the value of each choice depends on the sequence of future choices.
- Why not pick the first balloon?
	- Bursting first changes neighbors immediately, so subproblems are not independent and reasoning gets messy.
	- Think the last balloon.

## Method1 - DP (top-down)
## Approach: 
- DP find the last balloon
- Pad border: `a = [1] + nums + [1]`
- `dp[l][r]`= maximum coins obtainable by bursting all balloons strictly inside the open interval`(l, r)`.
- if we assume the last burst balloon is `k`, the neighbor must be `l`, `r`
		- `k` is the last one, so `score = nums[l] + nums[k] + nums[r]`
		- before burst `k`, need to burst `(l, k)` and `(k, r)` which is `dp[l][k] + dp[k][r]`
### Complexity
- TC: O($n^3$)
	- $n^2$ memoized recursion each (l, r) once and iterate k in (l, r)
- SC: O($n^2$)

```python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1] + nums + [1]
        n = len(nums)

        memo = [[-1] * n for _ in range(n)]

        def dp(l, r):
            if l >= r:
                return 0
            
			if memo[l][r] != -1:
                return memo[l][r]

            best = 0
            for k in range(l + 1, r):
                coins = nums[l] * nums[k] * nums[r]
                coins += dp(l, k) + dp(k, r)
                best = max(best, coins)

            memo[l][r] = best
            return best

        return dp(0, n - 1) # burst ball between the two walls 
```
