## Link
[Interval List Intersections - LeetCode](https://leetcode.com/problems/interval-list-intersections/description/) - easy, medium
## Question
> You are given two lists of closed intervals, `firstList` and `secondList`, where `firstList[i] = [starti, endi]` and `secondList[j] = [startj, endj]`. Each list of intervals is pairwise **disjoint** and in **sorted order**.
> Return _the intersection of these two interval lists_.
> 
> A **closed interval** `[a, b]` (with `a <= b`) denotes the set of real numbers `x` with `a <= x <= b`.
> 
> The **intersection** of two closed intervals is a set of real numbers that are either empty or represented as a closed interval. For example, the intersection of `[1, 3]` and `[2, 4]` is `[2, 3]`.
>
> **Example 1:**
>> **Input:** firstList = `[[0,2],[5,10],[13,23],[24,25]]`, secondList = `[[1,5],[8,12],[15,24],[25,26]]`<br>
>> **Output:** `[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]` <br>
## Goal
- Given two lists of **sorted**, non-overlapping intervals (`firstList` and `secondList`). Return all the intervals where they **intersect**. Each interval is a pair `[start, end]` and is inclusive.
## Logic
1. Use two pointer (i for firstList, j for secondList)
2. At each step, check if `firstList[i]` and `secondList[j]` overlap
3. if overlap, add to the result
4. move the pointer that has smaller end
## Code
```python
from typing import List
class Solution:
    def intervalIntersection(self, firstList: List[List[int]], secondList: List[List[int]]) -> List[List[int]]:
        i = j = 0
        res = []
        while i < len(firstList) and j < len(secondList):
            l1_start, l1_end = firstList[i]
            l2_start, l2_end = secondList[j]

            cur_start = max(l1_start, l2_start)
            cur_end = min(l1_end, l2_end)
            
            if cur_start <= cur_end:
                res.append([cur_start, cur_end])
            
            if l1_end < l2_end:
                i += 1
            else:
                j += 1
            
        return res
```

## Complexity analysis
- Time Complexity: O(n+m)
	- `n = len(firstList)`
	- `m = len(secondList)`
- Space Complexity: O(1)