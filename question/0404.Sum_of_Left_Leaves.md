## Method1: DFS - top-down
### Complexity
- Bottom-up DFS time: O(n) 
- space: O(h)
```python
class Solution:
    def sumOfLeftLeaves(self, root: Optional['TreeNode']) -> int:
        
        def dfs(node, is_left):
            if not node:
                return 0
            if is_left and not node.left and not node.right:
                return node.val
            return dfs(node.left, True) + dfs(node.right, False)
        
        return dfs(root, False)
```

## Method2: DFS - bottom-up
### Complexity
- Top-down DFS time: O(n) 
- space: O(h) 
```python
class Solution:
    def sumOfLeftLeaves(self, root: Optional['TreeNode']) -> int:
        if not root: 
            return 0
        
        ans = self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)
        
        if root.left and not root.left.left and not root.left.right:
            ans += root.left.val

        return ans
```
## Method3: BFS - Iterative
### Complexity
- BFS Iterative  time: O(n) 
- Space: O(w)
```python
class Solution:
    def sumOfLeftLeaves(self, root: Optional['TreeNode']) -> int:
        if root.left == None and root.right == None:
            return 0

        queue = deque()
        queue.append((root, False))
        total = 0
        
        while queue:
            size = len(queue)
            for _ in range(size):
                node, flag = queue.popleft()

                if flag and not node.left and not node.right:
                    total += node.val

                if node.left:
                    queue.append((node.left, True))
                if node.right:
                    queue.append((node.right, False))
        
        return total
```