## Question
`node1.val + node2.val == k`
## Method 1 - DFS
### Approach
1. Use a set `seen` to store visited values.
2. Traverse the tree (DFS) recursively:
    - If current node is `None` → return `False`
    - If `(k - node.val)` is in `seen` → return `True`
    - Else, add `node.val` to `seen`
    - Recursively search both left and right subtrees
3. Return True if any recursive call finds a match.
### Complexity
- Time Complexity: O(n)
- Space Complexity: O(n)
### Code
```python
class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
        seen = set()

        def dfs(node):
            if not node:
                return False
            
            if (k - node.val) in seen:
                return True
            
            seen.add(node.val)
            
            return dfs(node.right) or dfs(node.left)
        
        return dfs(root)
```


## Method 2 - BFS
### Approach
1. Inorder traversal
2. check for pair sum
### Complexity
- Time Complexity: O(n)
- Space Complexity: O(n)
### Code
```python
class Solution:
    def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
        arr = []
        def dfs(node):
            if not node:
                return
            
            if node.left:
                dfs(node.left)
            
            arr.append(node.val)

            if node.right:
                dfs(node.right)
        dfs(root)

        left, right = 0, len(arr) - 1
        while left < right:
            total = arr[left] + arr[right]
            if total == k:
                return True
            if total > k:
                right -= 1
            else:
                left += 1
        
        return False
```
