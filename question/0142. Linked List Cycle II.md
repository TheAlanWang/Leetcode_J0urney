## Question

## Method - Tortoise and Hare algorithm
### Approach
- slow = distance_from_start + distance_from_cycle
- fast = distance_from_start + distance_from_cycle + n_times_cycle
So: 
- $2 * slow = fast$
- $2*(distanceFromStart + distanceFromCycle) = distanceFromStart + distanceFromCycle+ nTimesCycle$
- $distanceFromStart + distanceFromCycle = nTimesCycle$
- $distanceFromStart = nTimesCycle - distanceFromCycle$

(Distance from *Old_slow_point to Cycle Start* = `nTimesCycle - distanceFromCycle` ) equal to *Distance from Head*

#### Complexity
- Time Complexity: O(n)
- Space Complexity: O(1)
### Code
```python
class Solution:
    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:
        
        def find_cycle_start(meet):
            slow = head
            while slow != meet:
                slow = slow.next
                meet = meet.next
            return slow

        fast = slow = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return find_cycle_start(slow)
        return None
```