link: [Find X-Sum of All K-Long Subarrays II](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-ii/)

## Question
- nums, k, x
- `answer[i] = x_sum of nums[i..i + k - 1]`
- x_sum is top x frequency elements
## Method
### Approach
- Create a data structure can Add, Remove, Sum. Include:
	- SortedList (store k num), store `[(freq, num)]`
	- SortedList (store remain), store `[(freq, num)]`
	- hashmap, `{num: freq}`
	- cur_sum
- Define Function
	- def balance()
		- if top > x
		- if top < x and remain
		- if top and remain and`top[0] < remain[-1]`
#### Complexity
- Time Complexity: $O(nlogn)$
- Space Complexity: $O(n)$
### Code
```python
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        top = SortedList()      # freq: num
        remain = SortedList()   # freq: num
        dic = defaultdict(int)
        cur_sum = 0

        def balance():
            nonlocal cur_sum

            if len(top) > x:
                freq, num = top.pop()
                remain.add((freq, num))
                cur_sum -= freq * num
            
            if len(top) < x and remain:
                freq, num = remain.pop()
                top.add((freq, num))
                cur_sum += freq * num

            if top and remain and top[0] < remain[-1]:
                f1, n1 = top.pop(0)
                f2, n2 = remain.pop()
                top.add((f2, n2))
                remain.add((f1, n1))
                cur_sum += (f2 * n2) - (f1 * n1)

        def add(num):
            nonlocal cur_sum
            
            if num in dic:
                prev = (dic[num], num)
                if prev in top:
                    top.remove(prev)
                    cur_sum -= dic[num] * num
                else:
                    remain.remove(prev)

            dic[num] += 1
            top.add((dic[num], num))
            cur_sum += dic[num] * num
            balance()

        def remove(num):
            nonlocal cur_sum
            if num in dic:
                prev = (dic[num], num)
                if prev in top:
                    top.remove(prev)
                    cur_sum -= dic[num] * num
                else:
                    remain.remove(prev)

            dic[num] -= 1
            if dic[num] == 0:
                del dic[num]
            else:
                top.add((dic[num], num))
                cur_sum += dic[num] * num
            balance()
        
        res = []
        for i in range(k):
            add(nums[i])
        res.append(cur_sum)
        
        for i in range(k, len(nums)):
            remove(nums[i-k])
            add(nums[i])
            res.append(cur_sum)
        return res
```
## Extra
### SortedList
```python
from sortedcontainers import SortedList

temp = SortedList()
temp.remove()  # O(N)
temp.pop()     # O(log N)
len(temp)      # O(1)
```