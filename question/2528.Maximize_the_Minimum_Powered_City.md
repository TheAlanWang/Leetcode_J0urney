link: [2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)
## Question


## Method 1 - Binary Search + Greedy
#### *Diff Array* concept
```
stations =   [1, 2, 4, 5, 0], r = 1
diff_array = [+1, x, -1, x, x]
diff_array = [+1+2, x, -1, -2, 0]          idx = 1, affect range is [0, 2], subtract on right + 1 = 3
diff_array = [+1+2, +4, -1, -2, -4]        idx = 2, affect range is [1, 3], subtract on right + 1 = 4
diff_array = [+1+2, +4, -1+5, -2, -4, -5]  idx = 3, affect range is [2, 4], subtract on right + 1 = 5

-> diff[0] = 3, [+1+2]
-> diff[1] = 7, which is sum[+1+2, +4]
-> diff[2] = 11, which is sum[+1+2, +4, -1+5]
-> ...
So use *prefix sum* can get the value

now add power station, left_side +1 in diff[0], right_side -1 in diff[3], right_idx is [left + 2*r + 1]
[+1+2 +1, +4, -1+5, -2 -1, -4, -5]
```
#### Complexity
- Time Complexity: $O(n*log(sum(Stations)+k))$
- Space Complexity: $O(n)$
### Code
```python
class Solution:
    def maxPower(self, stations: List[int], r: int, k: int) -> int:
        n = len(stations)
        diff = [0] * (n + 1)
        
        # construct differnt array
        for i in range(n):
            left = max(i - r, 0)
            right = min(i + r + 1, n)
            diff[left] += stations[i]
            diff[right] -= stations[i]
        
        def can_achieve(target_p):
            cur_p = 0
            cur_k = k
            diff_cpy = diff[:]
            for i in range(n):
                cur_p += diff_cpy[i]
                if cur_p < target_p:
                    additional = target_p - cur_p
                    if additional > cur_k:
                        return False
                    cur_k -= additional
                    cur_p += additional
                    
                    diff_cpy[i] += additional
                    # i is left_b, add 2*r to right_bound
                    right = min(i + 2 * r + 1, n)
                    diff_cpy[right] -= additional
            return True

        
        low, high = min(stations), sum(stations) + k
        while low <= high:
            target_p = (low + high) // 2
            if can_achieve(target_p):
                res = target_p
                low = target_p + 1
            else:
                high = target_p - 1
        return res
```