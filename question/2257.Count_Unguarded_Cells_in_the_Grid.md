## Method 1 - Grid sweep

### Approach

#### Complexity
- Time Complexity: $O(m*n+G*(m+n))$
- Space Complexity: $O(m*n)$
### Code:
```python
class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
        rows, cols = m, n
        grid = [[0] * cols for _ in range(rows)]

        for r, c in guards:
            grid[r][c] = 2
        
        for r, c in walls:
            grid[r][c] = 3
        
        dirs = ((1, 0), (-1, 0), (0, 1), (0, -1))

        for r, c in guards:
            for dr, dc in dirs:
                nr, nc = r + dr, c + dc
                while (
                    (0 <= nr < rows and 0 <= nc < cols) and
                    grid[nr][nc] != 2 and 
                    grid[nr][nc] != 3
                ):
                    if grid[nr][nc] == 0:
                        grid[nr][nc] = 1
                    nr += dr
                    nc += dc

        count = 0
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == 0:
                    count += 1
                
        return count
```

## Method 2 - BFS
### Approach
1. not suitable for bfs
#### Complexity
- Time Complexity: O($m*n$)
- Space Complexity:O($m*n$)
### Code
```python
from collections import deque
from typing import List, Set, Tuple

class Solution:
    def countUnguarded(self, m: int, n: int, guards: List[List[int]], walls: List[List[int]]) -> int:
        rows, cols = m, n
        wall = {(r, c) for r, c in walls}
        guard = {(r, c) for r, c in guards}
        seen = set()

        DIRS = [(-1,0), (1,0), (0,-1), (0,1)]  # up, down, left, right

        # visited per direction to allow rays to pass through already-seen cells
        visited_dir: Set[Tuple[int,int,int]] = set()

        for gr, gc in guards:
            for d, (dr, dc) in enumerate(DIRS):
                r, c = gr + dr, gc + dc
                if 0 <= r < rows and 0 <= c < cols and (r, c) not in wall and (r, c) not in guard:
                    if (r, c, d) not in visited_dir:
                        visited_dir.add((r, c, d))

                        q = deque([(r, c, d)])
                        while q:
                            cr, cc, di = q.popleft()
                            # stop if blocked
                            if (cr, cc) in wall or (cr, cc) in guard:
                                continue
                            # mark watched
                            seen.add((cr, cc))
                            # continue straight in the same direction
                            dr2, dc2 = DIRS[di]
                            nr, nc = cr + dr2, cc + dc2
                            if 0 <= nr < rows and 0 <= nc < cols:
                                if (nr, nc, di) not in visited_dir and (nr, nc) not in wall and (nr, nc) not in guard:
                                    visited_dir.add((nr, nc, di))
                                    q.append((nr, nc, di))

        total = rows * cols
        blocked = len(wall) + len(guard)
        return total - blocked - len(seen)
```