## Question
Given an `m x n` binary matrix `mat`, return the distance of the nearest `0` for each cell.
The distance between two cells sharing a common edge is `1`.

## Method 1
### Analysis:
- Each `0` is a source
- We have **multiple starting points** that spread out simultaneously
- Each move costs the **same weight** (unweighted graph).
- We need to find the **minimum distance or minimum steps** to something.
### Approach - Multi-source BFS
1. Initialize queue
    - Enqueue all `(r, c)` where `mat[r][c] == 0`.    
    - Set all other cells to `∞` (unvisited distance).
2. Run BFS
    - Pop `(r, c)` from queue.
    - For each of its 4 directions:    
        - If the neighbor `(nr, nc)` is within bounds and  
            `mat[nr][nc] > mat[r][c] + 1` →  
            update and enqueue it.
3. Return updated matrix.

### Complexity
- Time Complexity: O($m*n$)
- Space Complexity: O($m*n$)
### Code
```python
from typing import List
from collections import deque

class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        rows, cols = len(mat), len(mat[0])
        q = deque()

        # 1) Initialize queue with all zeros; set ones to INF
        INF = rows + cols + 1
        for r in range(rows):
            for c in range(cols):
                if mat[r][c] == 0:
                    q.append((r, c))          # distance 0 sources
                else:
                    mat[r][c] = INF           # unknown yet

        # 2) Multi-source BFS: relax neighbors
        dirs = ((1, 0), (-1, 0), (0, 1), (0, -1))
        while q:
            r, c = q.popleft()
            for dr, dc in dirs:
                nr, nc = r + dr, c + dc
                if 0 <= nr < rows and 0 <= nc < cols:
                    if mat[nr][nc] > mat[r][c] + 1:
                        mat[nr][nc] = mat[r][c] + 1
                        q.append((nr, nc))

        return mat
```