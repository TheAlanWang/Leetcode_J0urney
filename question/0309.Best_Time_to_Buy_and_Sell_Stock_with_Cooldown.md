## Question


## Method 1: DP + memo

### Approach
`memo = {(idx, can_buy): max_profit}`  means:
- `memo[(idx, can_buy)]` = maximum profit achievable starting from day idx with state can_buy
#### Transition
- if can_buy:
	- buy -> (idx + 1, not buy)
	- cooldown
- if not can_buy:
	- sell -> (idx + 2, can_buy)
	- cooldown
- return max
### Complexity
- Time Complexity: O(n)
- Space Complexity: O(n)
### Code
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        memo = {}
        def dfs(idx, canbuy):
            if idx >= len(prices):
                return 0

            # memorization
            if (idx, canbuy) in memo:
                return memo[(idx, canbuy)]

            if canbuy:
                buy = dfs(idx + 1, False) - prices[idx]
                cooldown = dfs(idx + 1, True)
                memo[(idx, canbuy)] = max(buy, cooldown)
            else:
                sell = dfs(idx + 2, True) + prices[idx]
                cooldown = dfs(idx + 1, False)
                memo[(idx, canbuy)] = max(sell, cooldown)
            return memo[(idx, canbuy)]

        return dfs(0, True)

```
