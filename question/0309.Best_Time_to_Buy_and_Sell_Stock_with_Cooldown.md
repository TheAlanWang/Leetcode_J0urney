## Question
- We can buy stock and sell stock multiple times
- After sell, there is cool down day. 

## Method 1: DP (Optimal)
#### Complexity
- Time Complexity: O(n)
- Space Complexity: O(1)
### Code
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0

        hold = -prices[0]     # best profit if holding a stock today
        sold = float('-inf')  # best profit if sold today (cooldown tomorrow)
        rest = 0              # best profit if not holding and not sold today

        for p in prices[1:]:
            prev_hold, prev_sold, prev_rest = hold, sold, rest
            hold = max(prev_hold, prev_rest - p)  # keep holding or buy today
            sold = prev_hold + p                  # sell today
            rest = max(prev_rest, prev_sold)      # stay idle or come off cooldown

        return max(sold, rest)

```
## Method 2: DP + memo

### Approach
`memo = {(idx, can_buy): max_profit}`  means:
- `memo[(idx, can_buy)]` = maximum profit achievable starting from day idx with state can_buy
#### Transition
- if can_buy:
	- choose to buy -> (idx + 1, not buy)
	- choose to cooldown -> (idx + 1, True), cooldown still can buy
- if not can_buy:
	- choose to sell -> (idx + 2, can_buy)
	- choose to cooldown -> (idx + 1,  *False*), we have stock so that we can not buy
- return max
#### Complexity
- Time Complexity: O(n)
- Space Complexity: O(n)
### Code
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        memo = {}
        def dfs(idx, canbuy):
            if idx >= len(prices):
                return 0

            # memorization
            if (idx, canbuy) in memo:
                return memo[(idx, canbuy)]

            if canbuy:
                buy = dfs(idx + 1, False) - prices[idx]  # buy now
                cooldown = dfs(idx + 1, True)            # 
                memo[(idx, canbuy)] = max(buy, cooldown)
            else:
                sell = dfs(idx + 2, True) + prices[idx]
                cooldown = dfs(idx + 1, False)
                memo[(idx, canbuy)] = max(sell, cooldown)
            return memo[(idx, canbuy)]

        return dfs(0, True)

```

## Method3 - Backtracking
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        n = len(prices)
        
        memo = {}
        def dfs(start):
            if start >= n:
                return 0

            max_profit = 0
            for buy in range(start, n - 1):
                profit_for_this_buy = 0
                for sell in range(buy + 1, n):
                    profit = (
                        dfs(sell + 2)
                        - prices[buy]
                        + prices[sell]
                    )
                    if profit > profit_for_this_buy:
                        profit_for_this_buy = profit
                
                if max_profit < profit_for_this_buy:
                    max_profit = profit_for_this_buy
                
            return max_profit
        
        return dfs(0)

```