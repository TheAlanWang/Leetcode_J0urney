## Method 1 - sliding window
### Approach
- **Right pointer:**
	- Change a character from “exactly matched” → “too many” → need `-1`
	- Or from “not enough” → “exactly matched” → need `+1`
- **Left pointer:**
	- Change from “exactly matched” → “less than” → need `-1`
	- Or from “too many” → “exactly matched” → need `+1`
### Complexity
- Time Complexity: O(n)
- Space Complexity:O(1)
### Code
```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        if len(s1) > len(s2):
            return False
        
        need_dic = defaultdict(int)
        win_dic = defaultdict(int)
        
        for char in s1:
            need_dic[char] += 1

        need_count = len(need_dic)
        win_count = 0
        left = right = 0

        while right < len(s2):
            rch = s2[right]
            if rch in need_dic:
                # before adding: if it was “exactly matched”, now it will be “too many”
                if win_dic[rch] == need_dic[rch]:
                    win_count -= 1
                win_dic[rch] += 1
                # after adding: if it becomes “exactly matched”, increment
                if win_dic[rch] == need_dic[rch]:
                    win_count += 1

            # shrink if window too big
            while right - left + 1 > len(s1):
                lch = s2[left]
                if lch in need_dic:
                    if win_dic[lch] == need_dic[lch]:
                        win_count -= 1
                    win_dic[lch] -= 1
                    if win_dic[lch] == need_dic[lch]:
                        win_count += 1
                left += 1

            if right - left + 1 == len(s1) and win_count == need_count:
                return True

            right += 1
        
        return False
```
