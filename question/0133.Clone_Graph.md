## Link
[Clone Graph - LeetCode](https://leetcode.com/problems/clone-graph/description/) - medium
## Question
> Example 1:
>>  Input: adjList = `[[2,4],[1,3],[2,4],[1,3]]`
>>  Output: `[[2,4],[1,3],[2,4],[1,3]]`
>> **Explanation:** There are 4 nodes in the graph.
>> 	  - 1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
>> 	  - 2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
>> 	  - 3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
>> 	  - 4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
### Goal
- Given a **reference to a node** in a connected **undirected graph**, return a **deep copy** (clone) of the entire graph.

## Method 1 - BFS
1. Visit each node once
2. For each node:
	- If a neighbor hasn't been cloned yet:
		- Clone it, and enqueue it
	- Always append the cloned neighbor to the current nodeâ€™s cloned `neighbors` list
3. Return the clone of the **starting node**

Hint:
- use *dictionary* store visited node {original node: cloned node}
### Code
```python
class Solution:
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        if not node:
            return None

        cloned = {}
        queue = deque([node])
        cloned[node] = Node(node.val)

        while queue:
            curr = queue.popleft()
            for nei in curr.neighbors:
                if nei not in cloned:
                    cloned[nei] = Node(nei.val)
                    queue.append(nei)
                cloned[curr].neighbors.append(cloned[nei])

        return cloned[node]
```

## Method 2 - DFS
#### Complexity
- Time Complexity: O(N + E)
- Space Complexity: O(N)
```python
from typing import Optional
class Solution:
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        if not node:
            return None
        return self.dfs(node)
    
    def dfs(self, node, clone_map={}):
        if node in clone_map:
            return clone_map[node]
        
        cloned_node = Node(node.val)
        clone_map[node] = cloned_node

        for nei in node.neighbors:
            cloned_nei = self.dfs(nei, clone_map)
            cloned_node.neighbors.append(cloned_nei)
        return cloned_node
```
