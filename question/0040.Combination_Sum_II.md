## Question

> **Example 1:**
>> Input: candidates = `[2,5,2,1,2]`, target = `5`
>> Output: `[[1,2,2],[5]]`

## Method 1 - Backtracking
### Approach: Backtracking
States: (idx, path, total)
Transitions:
- Use the first occurrence at a level(because it represents a new branch);
- skip later equals at the same level.
### Complexity
- Time Complexity: O($2^n$)
- Space Complexity: O(n)

```python
def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
    candidates = sorted(candidates)

    res = []
    def dfs(start, path, total):
        if total > target:
            return

        if total == target:
            res.append(path[:])
            return

        for idx in range(start, len(candidates)):
            if idx != start and candidates[idx] == candidates[idx-1]:
                continue

            path.append(candidates[idx])
            dfs(idx + 1, path, total + candidates[idx])
            path.pop()

    dfs(0, [], 0)
    return res
```
